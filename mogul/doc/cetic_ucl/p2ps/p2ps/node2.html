<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>2 Application Programming Interface</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node1.html#chapter.introduction">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node3.html#chapter.eventsmessages">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.p2ps_api"><H1><A name="chapter.p2ps_api">2 Application Programming Interface</A></H1><P>This chapter enumerates and describes the classes and the procedures provided by the <CODE>P2PS</CODE> library. The <CODE>P2PS</CODE> library has a simple structure. It contains the class <CODE>P2PServices</CODE>, procedures to (un)wrap an access point token, and procedures to compute network configuration parameters. </P><DIV id="section.p2ps.p2pservices"><H2><A name="section.p2ps.p2pservices">2.1 <CODE>P2PS<SPAN class="keyword">.</SPAN>p2pServices</CODE> class </A></H2><P>The class <CODE>P2PServices</CODE> offers different P2P services. Particularly, it provides means to create and to join a P2P network, and communication primitives to exchange messages among nodes. <CODE>P2PServices</CODE> objects can be initiated either with method <CODE>createNet</CODE> or with method <CODE>joinNet</CODE>. </P><DL><DT><CODE>createNet</CODE> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>createNet(netConfig:&nbsp;&nbsp;</CODE><CODE>+<I>NetC</I></CODE><CODE>&nbsp;&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;NetConfig<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nodeConfig:&nbsp;</CODE><CODE>+<I>NodeC</I></CODE><CODE>&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;NodeConfig<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;apConfig:&nbsp;&nbsp;&nbsp;</CODE><CODE>+<I>APC</I></CODE><CODE>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;APConfig<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msgStrm:&nbsp;&nbsp;&nbsp;&nbsp;</CODE><CODE>?<I>MS</I></CODE><CODE>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;_<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evntStrm:&nbsp;&nbsp;&nbsp;</CODE><CODE>?<I>ES</I></CODE><CODE>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;_)</CODE></BLOCKQUOTE><P></P></BLOCKQUOTE></DD><DD><P>Create a P2P network, i.e., the first node in the network. Configure the P2P network, node, and local node's access point by means of records <CODE><I>NetConfig</I></CODE>, <CODE><I>NodeConfig</I></CODE>, and respectively <CODE><I>APConfig</I></CODE>. Returns the message and the event streams, <CODE><I>MS</I></CODE> and <CODE><I>ES</I></CODE>. For more about the message and event streams and their form refer to <A href="node3.html#chapter.eventsmessages">Chapter&nbsp;3</A>. Raises exception <CODE>p2ps(couldNotConfig&nbsp;reason:R&nbsp;comment:C)</CODE> when there was a problem with the configuration parameters. <CODE><I>R</I></CODE> is the tuple <CODE>Param<SPAN class="keyword">#</SPAN>Val</CODE> corresponding to the name and value of the parameter that caused the exception. Sometimes, a comment <CODE><I>C</I></CODE>, as a string, will be added for clarification. </P><P>In the following we give the default values of the configuration records <CODE><I>NetConfig</I></CODE>, <CODE><I>NodeConfig</I></CODE> and <CODE><I>APConfig</I></CODE>. One can specify different values for the configuration parameters if need be. </P><P><CODE>NetConfig</CODE></P><P>The <CODE>NetConfig</CODE> record contains the parameters characterizing the P2P network. Only the Tango protocol is currently supported. Beside the name of the protocol, the corresponding parameters are: the maximum network size, the exponential factor, and the size of the successor list. They should be positive integers. The maximum network size should be greater than the exponential factor. Currently, only odd values greater than 2 are allowed for the exponential factor. See <A href="node2.html#section.p2ps.computenetconfig">Section&nbsp;2.3</A> for the relation between maximum network size, exponential factor, maximum number of hops, and the routing table size. </P><BLOCKQUOTE class="code"><CODE>netConfig(protocol:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tango<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maxNetSize:&nbsp;&nbsp;&nbsp;2131<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expFactor:&nbsp;&nbsp;&nbsp;&nbsp;3<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;succListSize:&nbsp;10)</CODE></BLOCKQUOTE><P> </P><P><CODE>NodeConfig</CODE></P><P>The <CODE>NodeConfig</CODE> record contains the parameters characterizing the local P2P node. They are in relation with the network parameters specified with <CODE>NetConfig</CODE>. The node Id should be a positive integer, inferior to the maximum network size. If not provided, a random value is chosen. The field at feature <CODE>useProxy</CODE> should be <CODE><SPAN class="keyword">false</SPAN></CODE> meaning that this node will be an integral part of the <CODE>P2PS</CODE> network. </P><BLOCKQUOTE class="code"><CODE>nodeConfig(nodeId:&nbsp;&nbsp;&nbsp;randomly_chosen&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;useProxy:&nbsp;<SPAN class="keyword">false</SPAN>)</CODE></BLOCKQUOTE><P> </P><P><CODE>APConfig</CODE></P><P>The <CODE>APConfig</CODE> record contains the parameters characterizing the local access point (for more about access point, see <A href="node2.html#section.p2ps.wrapap">Section&nbsp;2.2</A>). Currently, the local access point is characterized by an Ip address and a port number. The Ip should be given as a string, and the port as a positive integer. If Ip is not provided, a map of the host name of the computer to an Ip will be done. The Ip should only be set if the operating system, by some reason, returns a faulty one. If port is not provided, a random one is chosen. </P><BLOCKQUOTE class="code"><CODE>apConfig(ip:&nbsp;localhost&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pn:&nbsp;randomly_chosen)</CODE></BLOCKQUOTE><P> </P></DD><DT><CODE>joinNet</CODE> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>joinNet(remoteAP:&nbsp;&nbsp;&nbsp;</CODE><CODE>+<I>RemAP</I></CODE><CODE>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nodeConfig:&nbsp;</CODE><CODE>+<I>NodeC</I></CODE><CODE>&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;NodeConfig<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;apConfig:&nbsp;&nbsp;&nbsp;</CODE><CODE>+<I>APC</I></CODE><CODE>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;APConfig<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msgStrm:&nbsp;&nbsp;&nbsp;&nbsp;</CODE><CODE>?<I>MS</I></CODE><CODE>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;_<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evntStrm:&nbsp;&nbsp;&nbsp;</CODE><CODE>?<I>ES</I></CODE><CODE>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;_)</CODE></BLOCKQUOTE><P></P></BLOCKQUOTE></DD><DD><P>Create a node and join it to the P2P network to which the access point token <CODE><I>RemAP</I></CODE> is provided (for more about access point, see <A href="node2.html#section.p2ps.wrapap">Section&nbsp;2.2</A>). Configure the P2P node and the local node's access point by means of records <CODE><I>NodeConfig</I></CODE> and respectively <CODE><I>APConfig</I></CODE>. Returns the message and the event streams, <CODE><I>MS</I></CODE> and <CODE><I>ES</I></CODE>. For more about the message and event streams and their form refer to <A href="node3.html#chapter.eventsmessages">Chapter&nbsp;3</A>. Raises exception <CODE>p2ps(couldNotConfig&nbsp;reason:R&nbsp;comment:C)</CODE> when there was a problem with the configuration parameters. <CODE><I>R</I></CODE> is the tuple <CODE>Param<SPAN class="keyword">#</SPAN>Val</CODE> corresponding to the name and value of the parameter that caused the exception. Sometimes, a comment <CODE><I>C</I></CODE>, as a string, will be added for clarification. Raises exception <CODE>p2ps(couldNotJoin)</CODE> if there was a problem when joining, such as an obsolete token. Raises exception <CODE>p2ps(nodeAlreadyInNetwork)</CODE> if this node is already part of a <CODE>P2PS</CODE> network. Raises exception <CODE>p2ps(versionMismatch&nbsp;pversion:PV&nbsp;eversion:EV)</CODE> if the version of the this package is different than the version of the network. <CODE><I>PV</I></CODE> is the version of this package and <CODE><I>EV</I></CODE> is the expected version, i.e., the <CODE>P2PS</CODE> version of the nodes in the network to join to. </P><P>In the following we give the default values of the configuration records <CODE><I>NetConfig</I></CODE>, <CODE><I>NodeConfig</I></CODE> and <CODE><I>APConfig</I></CODE>. One can specify different values for the configuration parameters if need be. </P><P><CODE>NodeConfig</CODE></P><P>The <CODE>NodeConfig</CODE> record contains the parameters characterizing the local P2P node. They are in relation with the network parameters. The node Id should be a positive integer inferior to the maximum size of the network to join to. If not provided, a random value is chosen. If the field at feature <CODE>useProxy</CODE> is <CODE><SPAN class="keyword">true</SPAN></CODE>, then this node will be responsible only for the key corresponding to its Id, and it will interact with the network via a proxy node, i.e., its successor. This functionality is useful when dealing with nodes behind firewalls, or with nodes with limited resources. When <CODE>useProxy</CODE> is <CODE><SPAN class="keyword">false</SPAN></CODE>, this node will be an integral part of the <CODE>P2PS</CODE> network. </P><BLOCKQUOTE class="code"><CODE>nodeConfig(nodeId:&nbsp;&nbsp;&nbsp;randomly_chosen&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;useProxy:&nbsp;<SPAN class="keyword">false</SPAN>)</CODE></BLOCKQUOTE><P> </P><P><CODE>APConfig</CODE></P><P>The <CODE>APConfig</CODE> record contains the parameters characterizing the local access point (for more about access point, see <A href="node2.html#section.p2ps.wrapap">Section&nbsp;2.2</A>). Currently, the local access point is characterized by an Ip address and a port number. The Ip should be given as a string, and the port as a positive integer. If Ip is not provided, a map of the host name of the computer to an Ip will be done. The Ip should only be set if the operating system, by some reason, returns a faulty one. If a port is not provided, a random one is chosen. </P><BLOCKQUOTE class="code"><CODE>apConfig(ip:&nbsp;localhost&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pn:&nbsp;randomly_chosen)</CODE></BLOCKQUOTE><P> </P></DD><DT><CODE>leaveNet</CODE> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>leaveNet&nbsp;</CODE></BLOCKQUOTE><P></P></BLOCKQUOTE></DD><DD><P>Detach this node from the <CODE>P2PS</CODE> network. Terminate the message and the event streams (i.e., with <CODE>nil</CODE>). After calling <CODE>leaveNet</CODE>, a node won't accept messages for sending any more. Trying to send a message will raise exception <CODE>p2ps(nodeHasLeft)</CODE>. </P></DD><DT><CODE>send</CODE> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>send(dst:&nbsp;&nbsp;&nbsp;&nbsp;</CODE><CODE>+<I>NId</I></CODE><CODE>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msg:&nbsp;&nbsp;&nbsp;&nbsp;</CODE><CODE>+<I>Msg</I></CODE><CODE>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;toResp:&nbsp;</CODE><CODE>+<I>TR</I></CODE><CODE>&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;<SPAN class="keyword">false</SPAN>)</CODE></BLOCKQUOTE><P></P></BLOCKQUOTE></DD><DD><P>If <CODE><I>TR</I></CODE> is <CODE><SPAN class="keyword">false</SPAN></CODE>, send message <CODE><I>Msg</I></CODE> to node with Id <CODE><I>NId</I></CODE>. Otherwise, if <CODE><I>TR</I></CODE> is <CODE><SPAN class="keyword">true</SPAN></CODE>, <CODE><I>NId</I></CODE> is considered to be a key, and the message is sent to the key's responsible. The send is asynchronous and does not provide delivery guarantee. Raise exception <CODE>p2ps(nodeHasLeft)</CODE> if the node has already left. </P></DD><DT><CODE>rsend</CODE> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>rsend(dst:&nbsp;&nbsp;&nbsp;&nbsp;</CODE><CODE>+<I>NId</I></CODE><CODE>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msg:&nbsp;&nbsp;&nbsp;&nbsp;</CODE><CODE>+<I>Msg</I></CODE><CODE>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ack:&nbsp;&nbsp;&nbsp;&nbsp;</CODE><CODE>+<I>Ack</I></CODE><CODE>&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;_<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context:</CODE><CODE>+<I>C</I></CODE><CODE>&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;nil)</CODE></BLOCKQUOTE><P></P></BLOCKQUOTE></DD><DD><P>Send <CODE><I>Msg</I></CODE> to node <CODE><I>NId</I></CODE> reliably. It is reliable in the sense that all messages sent with <CODE>rsend</CODE> from this node to <CODE><I>NId</I></CODE> will eventually be delivered in a FIFO manner. This will implicitly create a connection between this node and the node <CODE><I>NId</I></CODE>, and thus generating the event <CODE>openconn</CODE> on the event stream. The <CODE><I>Ack</I></CODE> variable will be bound either to <CODE>acked</CODE> as soon as it is known that the message was acknowledged as received, or to <CODE>nonacked</CODE> when the connection is closed and there has not been received any acknowledgment for that message. In order to easily recover the non acked messages when the connection is ungracefully closed, a &quot;context&quot; <CODE><I>C</I></CODE> can be provided with each message to be sent. This context, that can be any Oz entity, will be paired with each non acked message returned by <CODE>P2PS</CODE> with the event <CODE>closeconn</CODE>. The send is asynchronous but one can synchronize on <CODE><I>Ack</I></CODE>. Raise exception <CODE>p2ps(nodeHasLeft)</CODE> if the node has already left. <EM>Note that this method is currently in tests</EM>. </P></DD><DT><CODE>multicast</CODE> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>multicast(dst:&nbsp;&nbsp;&nbsp;&nbsp;</CODE><CODE>+<I>LNId</I></CODE><CODE>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msg:&nbsp;&nbsp;&nbsp;&nbsp;</CODE><CODE>+<I>Msg</I></CODE><CODE>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;toResp:&nbsp;</CODE><CODE>+<I>TR</I></CODE><CODE>&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;<SPAN class="keyword">false</SPAN>)</CODE></BLOCKQUOTE><P></P></BLOCKQUOTE></DD><DD><P>If <CODE><I>TR</I></CODE> is <CODE><SPAN class="keyword">false</SPAN></CODE>, send message <CODE><I>Msg</I></CODE> to nodes corresponding to Ids found in list <CODE><I>LNId</I></CODE>, i.e., explicit multicast. If <CODE><I>TR</I></CODE> is <CODE><SPAN class="keyword">true</SPAN></CODE>, the Ids are considered to be keys, and the message is sent to the keys' responsibles. The send is asynchronous and does not provide delivery guarantee. Raise exception <CODE>p2ps(nodeHasLeft)</CODE> if the node has already left. </P></DD><DT><CODE>broadcast</CODE> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>broadcast(msg:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</CODE><CODE>+<I>Msg</I></CODE><CODE>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;toMyself:&nbsp;</CODE><CODE>+<I>TM</I></CODE><CODE>&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;<SPAN class="keyword">false</SPAN>)</CODE></BLOCKQUOTE><P></P></BLOCKQUOTE></DD><DD><P>Send message <CODE><I>Msg</I></CODE> to all the nodes in the <CODE>P2PS</CODE> network including, or not, the source node depending whether <CODE><I>TM</I></CODE> is set to <CODE><SPAN class="keyword">true</SPAN></CODE> or <CODE><SPAN class="keyword">false</SPAN></CODE>. <CODE><I>Msg</I></CODE> can be any Oz value. The send is asynchronous and does not provide delivery guarantee. Raise exception <CODE>p2ps(nodeHasLeft)</CODE> if the node has already left. </P></DD><DT><CODE>sendToSucc</CODE> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>sendToSucc(msg:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</CODE><CODE>+<I>Msg</I></CODE><CODE>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nrSucc:&nbsp;&nbsp;&nbsp;</CODE><CODE>+<I>N</I></CODE><CODE>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;toMyself:&nbsp;</CODE><CODE>+<I>TM</I></CODE><CODE>&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;<SPAN class="keyword">false</SPAN>)</CODE></BLOCKQUOTE><P></P></BLOCKQUOTE></DD><DD><P>Send message <CODE><I>Msg</I></CODE> to the <CODE><I>N</I></CODE> successors of this node. <CODE><I>Msg</I></CODE> can be any Oz value. If this node is part of the successor list and <CODE><I>TM</I></CODE><CODE><SPAN class="keyword">==true</SPAN></CODE>, send the message to it, too. Raise exception <CODE>p2ps(nrSuccTooLarge&nbsp;nrSucc:N)</CODE> if <CODE><I>N</I></CODE> is greater than the network parameter <CODE>succListSize</CODE> (see method <CODE>createNet</CODE>). The send is asynchronous and does not provide delivery guarantee. Raise exception <CODE>p2ps(nodeHasLeft)</CODE> if the node has already left. </P></DD><DT><CODE>getLocalAP</CODE> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>getLocalAP(</CODE><CODE>?<I>AP</I></CODE><CODE>)</CODE></BLOCKQUOTE><P></P></BLOCKQUOTE></DD><DD><P>Return the local access point <CODE><I>AP</I></CODE> of this node (for more about access point, see <A href="node2.html#section.p2ps.wrapap">Section&nbsp;2.2</A>). </P></DD><DT><CODE>getMsgStrm</CODE> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>getMsgStrm(</CODE><CODE>?<I>MS</I></CODE><CODE>}</CODE></BLOCKQUOTE><P></P></BLOCKQUOTE></DD><DD><P>Return a stream on which the received messages are available. For more about the message stream and the form of a messages refer to <A href="node3.html#section.eventsmessages.messages">Section&nbsp;3.1</A>. Note that the messages received before binding <CODE><I>MS</I></CODE> are not available on the stream. The stream will be ended (with <CODE>nil</CODE>) when this node leaves the network. </P></DD><DT><CODE>getEvntStrm</CODE> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>getEvntStrm(</CODE><CODE>?<I>ES</I></CODE><CODE>}</CODE></BLOCKQUOTE><P></P></BLOCKQUOTE></DD><DD><P>Return a stream on which events occurred in <CODE>P2PS</CODE> are available. For more about possible events refer to <A href="node3.html#section.eventsmessages.events">Section&nbsp;3.2</A>. Note that the events occurred before binding <CODE><I>ES</I></CODE> are not available on the stream. The stream will be ended (with <CODE>nil</CODE>) when this node leaves the network. </P></DD><DT><CODE>getNetConfig</CODE> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>getNetConfig(</CODE><CODE>?<I>NetConfig</I></CODE><CODE>)</CODE></BLOCKQUOTE><P></P></BLOCKQUOTE></DD><DD><P>Return the network configuration as a record in the same form as specified in method <CODE>createNet</CODE>. The values of the parameters correspond to the current P2P network the node takes part of. </P></DD><DT><CODE>getNodeConfig</CODE> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>getNodeConfig(</CODE><CODE>?<I>NodeConfig</I></CODE><CODE>)</CODE></BLOCKQUOTE><P></P></BLOCKQUOTE></DD><DD><P>Return the configuration of this node as a record in the same form as specified in methods <CODE>createNet</CODE> or <CODE>joinNet</CODE>. The values of the parameters are proper to this node. </P></DD><DT><CODE>getAPConfig</CODE> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>getAPConfig(</CODE><CODE>?<I>APConfig</I></CODE><CODE>)</CODE></BLOCKQUOTE><P></P></BLOCKQUOTE></DD><DD><P>Return the access point configuration of this node as a record in the same form as specified in methods <CODE>createNet</CODE> or <CODE>joinNet</CODE>. The values of the parameters are proper to this node. For details on access point, see <A href="node2.html#section.p2ps.wrapap">Section&nbsp;2.2</A>. </P></DD><DT><CODE>getFT</CODE> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>getFT(</CODE><CODE>?<I>FT</I></CODE><CODE>)</CODE></BLOCKQUOTE><P></P></BLOCKQUOTE></DD><DD><P>Return the current finger table <CODE><I>FT</I></CODE> of this node. <CODE><I>FT</I></CODE> has the form of a record with label <CODE>ft</CODE>. The record contains the node Ids of the fingers (i.e., the set of neighbors). The maximum number of fingers at a node depends on the maximum network size of the system (see <CODE>NetConfig</CODE>). For the positions for which the value of a finger is determined, its node Id is provided, otherwise <CODE><SPAN class="keyword">unit</SPAN></CODE> is provided. </P></DD><DT><CODE>getSucc</CODE> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>getSucc(</CODE><CODE>?<I>Succ</I></CODE><CODE>)</CODE></BLOCKQUOTE><P></P></BLOCKQUOTE></DD><DD><P>Return the Id of the successor of this node. A node alone in the network has itself as successor. </P></DD><DT><CODE>getPred</CODE> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>getPred(</CODE><CODE>?<I>Pred</I></CODE><CODE>)</CODE></BLOCKQUOTE><P></P></BLOCKQUOTE></DD><DD><P>Return the current Id of the predecessor of this node. A node alone in the network has itself as predecessor. </P></DD><DT><CODE>getSuccList</CODE> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>getSuccList(</CODE><CODE>?<I>SuccList</I></CODE><CODE>)</CODE></BLOCKQUOTE><P></P></BLOCKQUOTE></DD><DD><P>Return the current successor list of this node. <CODE><I>SuccList</I></CODE> has the form of a record with label <CODE>succlist</CODE>. The record contains the node Ids of the successors of this node. For the maximum number of successors of a node, see <CODE>NetConfig</CODE>. The Id of a node may appear in its successor list if the network is smaller than the maximum size of the successor list. </P></DD><DT><CODE>getClients</CODE> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>getClients(</CODE><CODE>?<I>Clients</I></CODE><CODE>)</CODE></BLOCKQUOTE><P></P></BLOCKQUOTE></DD><DD><P>Return a list with the Ids of the nodes that use this node as proxy. </P></DD><DT><CODE>getStatistics</CODE> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>getStatistics(</CODE><CODE>?<I>Stat</I></CODE><CODE>)</CODE></BLOCKQUOTE><P></P></BLOCKQUOTE></DD><DD><P>This method provides a set of information, most of it in the form of counters, about the status of the peer node. <CODE><I>Stat</I></CODE> is a record containing different fields whose meaning is the following. <CODE><I>UseProxy</I></CODE> is a boolean indicating whether the node uses, or not, a proxy to access to the overlay network. <CODE><I>NrDataMsgs_lcl</I></CODE> the number of data messages sent by this node. <CODE><I>NrDataMsgs_rm</I></CODE> the number of data messages forwarded by this node. <CODE><I>NrCtrlMsgs_lcl</I></CODE> the number of control messages send by this node. <CODE><I>NrCtrlMsgs_lcl</I></CODE> the number of control messages forwarded by this node. <CODE><I>NrAppMsgs</I></CODE> the number of messages sent by the application associated with this node. <CODE><I>NrFingerChgs</I></CODE> the number of times the finger table has changed. <CODE><I>NrSuccChgs</I></CODE> the number of times the successor has changed. <CODE><I>NrPredChgs</I></CODE> the number of times the predecessor has changed. <CODE><I>NrClients</I></CODE> the number of clients this node has. <CODE><I>NrOutLinks</I></CODE> the number of outgoing links. <CODE><I>NrInLinks</I></CODE> the number of incoming links. </P><BLOCKQUOTE class="code"><CODE>stat(useProxy:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</CODE><CODE><I>UseProxy</I></CODE><CODE>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nrDataMsgs_lcl:&nbsp;</CODE><CODE><I>NrDataMsgs_lcl</I></CODE><CODE>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nrDataMsgs_rm:&nbsp;&nbsp;</CODE><CODE><I>NrDataMsgs_rm</I></CODE><CODE>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nrCtrlMsgs_lcl:&nbsp;</CODE><CODE><I>NrCtrlMsgs_lcl</I></CODE><CODE>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nrCtrlMsgs_rm:&nbsp;&nbsp;</CODE><CODE><I>NrCtrlMsgs_rm</I></CODE><CODE>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nrAppMsgs:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</CODE><CODE><I>NrAppMsgs</I></CODE><CODE>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nrFingerChgs:&nbsp;&nbsp;&nbsp;</CODE><CODE><I>NrFingerChgs</I></CODE><CODE>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nrSuccChgs:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</CODE><CODE><I>NrSuccChgs</I></CODE><CODE>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nrPredChgs:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</CODE><CODE><I>NrPredChgs</I></CODE><CODE>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nrClients:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</CODE><CODE><I>NrClients</I></CODE><CODE>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nrOutLinks:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</CODE><CODE><I>NrOutLinks</I></CODE><CODE>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nrInLinks:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</CODE><CODE><I>NrInLinks</I></CODE><CODE>)</CODE></BLOCKQUOTE><P> </P></DD><DT><CODE>isResponsibleOf</CODE> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>isResponsibleOf(key:&nbsp;</CODE><CODE>+<I>Key</I></CODE><CODE>&nbsp;&nbsp;resp:&nbsp;</CODE><CODE>?<I>Resp</I></CODE><CODE>)</CODE></BLOCKQUOTE><P></P></BLOCKQUOTE></DD><DD><P>Return <CODE><SPAN class="keyword">true</SPAN></CODE> if this node is responsible of the key <CODE><I>K</I></CODE>. Otherwise, return <CODE><SPAN class="keyword">false</SPAN></CODE>. </P></DD></DL><P> </P></DIV><DIV id="section.p2ps.wrapap"><H2><A name="section.p2ps.wrapap">2.2 Access point token (un)wrapping</A></H2><P>An <EM>access point</EM> is encoded as a token that carries the access information to a <CODE>P2PS</CODE> node and, thus, to a <CODE>P2PS</CODE> network. The information it encapsulates is provided by the underlying communication level of <CODE>P2PS</CODE>. Currently, this information contains the Ip address of the machine on which the node runs and a port number. </P><P>To join a <CODE>P2PS</CODE> network, a node has to specify the access point <CODE><I>AP</I></CODE> of another node already in the network. One can either obtain the corresponding token from another node, or he can build it up with procedure <CODE>P2PS<SPAN class="keyword">.</SPAN>address2ap</CODE>, given the node's Ip address and port#. The opposite procedure is <CODE>P2PS<SPAN class="keyword">.</SPAN>ap2address</CODE> . </P><DL><DT><CODE>address2ap</CODE> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>address2ap(</CODE><CODE>+<I>IP</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>PN</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>AP</I></CODE><CODE>)</CODE></BLOCKQUOTE><P></P></BLOCKQUOTE></DD><DD><P>Given an Ip address <CODE><I>IP</I></CODE>, as a string, and a port number <CODE><I>PN</I></CODE>, as an integer, return the corresponding access point token <CODE><I>AP</I></CODE>. </P></DD><DT><CODE>ap2address</CODE> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>ap2address(</CODE><CODE>+<I>AP</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>IP</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>PN</I></CODE><CODE>)</CODE></BLOCKQUOTE><P></P></BLOCKQUOTE></DD><DD><P>Given an access point <CODE><I>AP</I></CODE>, return the Ip address <CODE><I>IP</I></CODE>, as a string, and the port number <CODE><I>PN</I></CODE>, as an integer. Raise exception <CODE>p2ps(wrongAPFormat&nbsp;ap:AP)</CODE> if <CODE><I>AP</I></CODE> is has a wrong format </P></DD></DL><P> </P></DIV><DIV id="section.p2ps.computenetconfig"><H2><A name="section.p2ps.computenetconfig">2.3 Compute network parameters</A></H2><P> One can be interested in computing the configuration parameters of her network by specifying some constraints. Then, a list of possible parameters can be provided from which one can choose the most suitable one. The procedure <CODE>P2PS<SPAN class="keyword">.</SPAN>computeParams</CODE> can be used to compute the parameters for a Tango network. </P><DL><DT><CODE>computeParams</CODE> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>computeParams(</CODE><CODE>+<I>NetParams</I></CODE><CODE>)</CODE></BLOCKQUOTE><P></P></BLOCKQUOTE></DD><DD><P>In Tango there is a strong relation between the maximum size of the network, the maximum number of hops to reach every node in the network, the size of the routing table at each node, and the exponential factor of the network. This method, computes all the possible combinations with respect to the given network parameters. <CODE><I>NetParams</I></CODE> is a record which must contain at least the field <CODE>minNetSize</CODE> corresponding to the minimum desired network size. The other constraints can be <CODE>maxHops</CODE>, <CODE>maxRTSize</CODE> and <CODE>maxExpFactor</CODE>, that is the maximum number of hops, the maximum size of the routing table and respectively the maximum exponential factor. Return a list of records of the form <CODE>param(expFactor:EF&nbsp;maxHops:MH&nbsp;maxNetSize:MS&nbsp;rtSize:RTS)</CODE>, where <CODE><I>EF</I></CODE> is the exponential factor, <CODE><I>MH</I></CODE> is the maximum number of hops, <CODE><I>MS</I></CODE> is the maximum network size, and <CODE><I>RTS</I></CODE> is the size of the routing table. The list can be empty if there is no solution found for the provided parameters.</P><P>For example, </P><BLOCKQUOTE class="code"><CODE>{P2PS<SPAN class="keyword">.</SPAN>computeParams&nbsp;r(minNetSize:200)}</CODE></BLOCKQUOTE><P> yields the following as output: </P><BLOCKQUOTE class="code"><CODE>[param(expFactor:199&nbsp;maxHops:1&nbsp;maxNetSize:200&nbsp;rtSize:199)&nbsp;&nbsp;<BR>&nbsp;param(expFactor:15&nbsp;&nbsp;maxHops:2&nbsp;maxNetSize:239&nbsp;rtSize:30)&nbsp;&nbsp;<BR>&nbsp;param(expFactor:7&nbsp;&nbsp;&nbsp;maxHops:3&nbsp;maxNetSize:433&nbsp;rtSize:21)&nbsp;&nbsp;<BR>&nbsp;param(expFactor:5&nbsp;&nbsp;&nbsp;maxHops:4&nbsp;maxNetSize:985&nbsp;rtSize:20)&nbsp;&nbsp;<BR>&nbsp;param(expFactor:3&nbsp;&nbsp;&nbsp;maxHops:5&nbsp;maxNetSize:571&nbsp;rtSize:15)]</CODE></BLOCKQUOTE><P> Whereas, if we add more constraints, such as the maximum size of the routing table <CODE>maxRTSize</CODE>, we can reduce the resulted domain. </P><BLOCKQUOTE class="code"><CODE>{P2PS<SPAN class="keyword">.</SPAN>computeParams&nbsp;r(minNetSize:200&nbsp;maxRTSize:16)}</CODE></BLOCKQUOTE><P> yields the following as output: </P><BLOCKQUOTE class="code"><CODE>[param(expFactor:3&nbsp;maxHops:5&nbsp;maxNetSize:571&nbsp;rtSize:15)]</CODE></BLOCKQUOTE><P> </P></DD></DL><P> </P></DIV><DIV id="section.p2ps.version"><H2><A name="section.p2ps.version">2.4 The package version</A></H2><P></P><DL><DT><CODE>version</CODE> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>version</CODE></BLOCKQUOTE><P></P></BLOCKQUOTE></DD><DD><P>A parameter bound to a value representing the version of the current P2PS package. The value is a string of the following form: &quot;P2PS <CODE>version</CODE> <CODE>YYYYMMDD</CODE>&quot;.</P></DD></DL><P> </P></DIV></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node1.html#chapter.introduction">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node3.html#chapter.eventsmessages">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS>Bruno Carton and Valentin Mesaros<BR></ADDRESS></BODY></HTML>
