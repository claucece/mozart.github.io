<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>Bidirectional session modules</TITLE><LINK href="http://www2.info.ucl.ac.be/people/ned/session/doc/ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><P class="margin"><A href="http://www2.info.ucl.ac.be/people/ned/session/index.html">Top</A></P><H1 align="center" class="title">Bidirectional session modules</H1><H2 align="center" class="authors">Donatien Grolaux</H2><DIV id="chapter.introduction"><H1><A name="chapter.introduction">1 Introduction</A></H1><P> The <CODE>Session</CODE> module provides a communication channel respecting this set of properties: </P><UL><LI><P>A <CODE>Session</CODE> instance obtained by <CODE>Session<SPAN class="keyword">.</SPAN>new</CODE> represents one side of a communication.</P></LI><LI><P>When two instances are connected together, they offer a bidirectional communication channel between these two points. Messages are received on a stream. There is only one reception stream per session instance that receives all messages from all successive connections of this instance.</P></LI><LI><P>At maximum two instances can be connected together at any time.</P></LI><LI><P>Any one of the two sides of a session communication channel can break the connection. Each side can then be connected back again together or to other session instances.</P></LI><LI><P>Each session instance also provides a free-for-all communication channel where anyone can send messages freely without having to connect. These messages are received on a distinctive stream. For example, an application wants to provide a remote control to several remote clients, but only one at a time. With the <CODE>Session</CODE> module, the application can use a single session instance to let only one remote client connect at a time. When the client wants to stop working with the application, it can stop the session, and another client can then take over. If a client is already connected to the application and another one wants to connect to it also, it can use the free-for-all channel to notify the application so. If there are several applications the client wants to connect to successively, it can do so using a single session instance.</P></LI><LI><P>Each session instance produces a link state stream. Connections, change of the communication link with the currently connected session and disconnections generate messages on that stream. This can be used to create fault-tolerant applications without using the <CODE>Fault</CODE> module. The possible messages on that stream are: </P><UL><LI><P><CODE>connect</CODE>: this session instance has just been connected to another session instance. Messages can be sent to the other site.</P></LI><LI><P><CODE>disconnect</CODE>: this session instance has been disconnected by the other session instance. No message can be sent while disconnected.</P></LI><LI><P><CODE>tempFail</CODE>: there is a communication problem that temporarily prevents the messages from arriving to the other site. A <CODE>tempFail</CODE> may change into <CODE>permFail</CODE> or <CODE>ok</CODE>, or stays forever (until the site decides to break the session). Note that the application can still send messages in this state, they will be buffered and send correctly if the communication turns <CODE>ok</CODE> or dropped if the communication is broken.</P></LI><LI><P><CODE>permFail</CODE>: the other site was detected crashed. It is the same as <CODE>disconnect</CODE>, except that there is no use to try and contact the other site anymore: it is dead forever.</P></LI><LI><P><CODE>ok</CODE>: after a <CODE>tempFail</CODE>, this state means the communication is fine again, messages are normally arriving at the other site.</P></LI></UL><P></P></LI></UL><P></P><P>This module also offers a session gate, which is a single access point for spawning multiple sessions. Typically, a server can start a gate that will create a different session per client. When a client has finished to work with the server, the session is closed and no more communication is possible between them. However, the client can use the gate again to create a new session with the server.</P><P>This module doesn't provide an access control over the session instances and the gates. The application should define its own using the <CODE>Connection</CODE> and <CODE>Ticket</CODE> modules, or the <CODE>SocketConnection</CODE> module.</P></DIV><DIV id="chapter.examples"><H1><A name="chapter.examples">2 Examples</A></H1><P>First example: a client-server implementation. </P><BLOCKQUOTE class="code"><CODE><SPAN class="comment">%%&nbsp;Server&nbsp;side<BR></SPAN><SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">Server</SPAN>&nbsp;Msg}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="comment">%%&nbsp;insert&nbsp;here&nbsp;the&nbsp;code&nbsp;that&nbsp;responds&nbsp;to&nbsp;Msg<BR></SPAN><SPAN class="keyword">end</SPAN>&nbsp;<BR>L<BR>G={Session<SPAN class="keyword">.</SPAN>newGate&nbsp;L}<BR>{SocketConnection<SPAN class="keyword">.</SPAN>offerOn&nbsp;5000&nbsp;G}<BR>{ForAll&nbsp;L<BR>&nbsp;<SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;S}&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ForAll&nbsp;{Session<SPAN class="keyword">.</SPAN>getStream&nbsp;S}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;M}&nbsp;{Server&nbsp;M}&nbsp;<SPAN class="keyword">end</SPAN>}<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;<SPAN class="keyword">end</SPAN>}<BR>&nbsp;<BR><SPAN class="comment">%%&nbsp;client&nbsp;side<BR></SPAN>G={SocketConnection<SPAN class="keyword">.</SPAN>take&nbsp;IP&nbsp;5000}&nbsp;<SPAN class="comment">%%&nbsp;IP&nbsp;contains&nbsp;the&nbsp;IP&nbsp;of&nbsp;the&nbsp;server<BR></SPAN>S={Session<SPAN class="keyword">.</SPAN>gateConnect&nbsp;G}&nbsp;<SPAN class="comment">%%&nbsp;S&nbsp;is&nbsp;a&nbsp;session&nbsp;connected&nbsp;to&nbsp;the&nbsp;server<BR></SPAN>{S<SPAN class="keyword">.</SPAN>aSend&nbsp;run}&nbsp;<SPAN class="comment">%%&nbsp;sends&nbsp;the&nbsp;run&nbsp;message&nbsp;to&nbsp;the&nbsp;server<BR></SPAN><SPAN class="keyword">...</SPAN></CODE></BLOCKQUOTE><P> Second example: a timer server that sends a tick every second. Only one client can connect at a time. </P><BLOCKQUOTE class="code"><CODE><SPAN class="comment">%%&nbsp;server&nbsp;side<BR></SPAN>S={Session<SPAN class="keyword">.</SPAN>new}<BR>{SocketConnection<SPAN class="keyword">.</SPAN>offerOn&nbsp;5000&nbsp;S}<BR><SPAN class="keyword">thread</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">Tick</SPAN>}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">try</SPAN>&nbsp;{Session<SPAN class="keyword">.</SPAN>aSend&nbsp;S&nbsp;tick}&nbsp;<SPAN class="keyword">catch</SPAN>&nbsp;_&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<SPAN class="keyword">skip</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Delay&nbsp;1000}&nbsp;{Tick}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;{Tick}<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;<BR><SPAN class="comment">%%&nbsp;client&nbsp;side<BR></SPAN>LS={Session<SPAN class="keyword">.</SPAN>new}<BR>{Browse&nbsp;{Session<SPAN class="keyword">.</SPAN>getStream&nbsp;LS}}<BR>RS={SocketConnection<SPAN class="keyword">.</SPAN>take&nbsp;IP&nbsp;5000}<BR>{Session<SPAN class="keyword">.</SPAN>connect&nbsp;LS&nbsp;RS}&nbsp;<SPAN class="comment">%%&nbsp;will&nbsp;fail&nbsp;if&nbsp;the&nbsp;server&nbsp;is&nbsp;not&nbsp;free<BR></SPAN><SPAN class="keyword">...</SPAN>&nbsp;<BR>{Session<SPAN class="keyword">.</SPAN>disconnect&nbsp;S}&nbsp;<SPAN class="comment">%%&nbsp;disconnects&nbsp;from&nbsp;the&nbsp;server&nbsp;=&gt;&nbsp;another&nbsp;client&nbsp;can&nbsp;take&nbsp;over</SPAN></CODE></BLOCKQUOTE><P></P></DIV><DIV id="chapter.reference"><H1><A name="chapter.reference">3 Reference</A></H1><P>Warning: local and remote session instances play a different role in the functions and procedures below. Except when otherwise stated, the first parameter is always a locally created session. Let's assume <CODE>Offer</CODE> is a function that makes an Oz entity remotely available, and <CODE>Obtain</CODE> the function that gets the offered reference: </P><TABLE align="center" bgcolor="#f0f0e0"><TR valign="top"><TH><P><CODE>SiteA</CODE></P></TH><TH><P><CODE>SiteB</CODE></P></TH></TR><TR valign="top"><TD><P><CODE>SA={Session<SPAN class="keyword">.</SPAN>new}</CODE></P></TD><TD><P><CODE>SB={Session<SPAN class="keyword">.</SPAN>new}</CODE></P></TD></TR><TR valign="top"><TD><P><CODE>{Offer&nbsp;SA}</CODE></P></TD><TD><P><CODE>&nbsp;</CODE></P></TD></TR><TR valign="top"><TD><P><CODE>&nbsp;</CODE></P></TD><TD><P><CODE>SR={Obtain}</CODE></P></TD></TR></TABLE><P> At this stage, <CODE>SiteB</CODE> has the remote reference <CODE>SR</CODE> to <CODE>SA</CODE> of <CODE>SiteA</CODE>. <CODE>SiteB</CODE> can connect both sessions by: </P><BLOCKQUOTE class="code"><CODE>{Session<SPAN class="keyword">.</SPAN>connect&nbsp;SB&nbsp;SR}</CODE></BLOCKQUOTE><P> However swapping the parameters is invalid: </P><BLOCKQUOTE class="code"><CODE>{Session<SPAN class="keyword">.</SPAN>connect&nbsp;SR&nbsp;SB}</CODE></BLOCKQUOTE><P> The first parameter of <CODE>Session<SPAN class="keyword">.</SPAN>connect</CODE> must be session local to <CODE>SiteB</CODE>, which is not the case here.</P><DIV id="chapter.reference.session"><H2><A name="chapter.reference.session">3.1 Session Reference</A></H2><P> </P><DL><DT><A name="label1"></A><SPAN class="index"><CODE>is</CODE></SPAN> <A name="label2"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Session<SPAN class="keyword">.</SPAN>is&nbsp;</CODE><CODE>+<I>X</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>B</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>tests whether <CODE><I>X</I></CODE> is a <CODE>Session</CODE>. <CODE><I>X</I></CODE> can be a remote session. </P></DD><DT><A name="label3"></A><SPAN class="index"><CODE>new</CODE></SPAN> <A name="label4"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Session<SPAN class="keyword">.</SPAN>new&nbsp;</CODE><CODE>?<I>S</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>returns a new session instance. </P></DD><DT><A name="label5"></A><SPAN class="index"><CODE>connect</CODE></SPAN> <A name="label6"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Session<SPAN class="keyword">.</SPAN>connect&nbsp;</CODE><CODE><I>S1</I></CODE><CODE>&nbsp;</CODE><CODE><I>S2</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>Connects <CODE><I>S1</I></CODE> with <CODE><I>S2</I></CODE>. Raises an exception if <CODE><I>S1</I></CODE> or <CODE><I>S2</I></CODE> are already connected to another session. Raises an exception if <CODE><I>S2</I></CODE> is unreachable. </P></DD><DT><A name="label7"></A><SPAN class="index"><CODE>disconnect</CODE></SPAN> <A name="label8"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Session<SPAN class="keyword">.</SPAN>disconnect&nbsp;</CODE><CODE><I>S</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>Disconnects <CODE><I>S</I></CODE> to whatever other session it was connected to. This is a synchronous disconnection, ie it waits for all pending messages to arrive before disconnecting. In case of <CODE>permFail</CODE>, the disconnection waits for a change of the communication status. If it resolves to <CODE>ok</CODE>, all pending messages are sent before disconnecting. If it resolves to <CODE>permFail</CODE> or <CODE>disconnect</CODE>, the disconnection is immediate, and pending messages may be lost in the process. </P></DD><DT><A name="label9"></A><SPAN class="index"><CODE>break</CODE></SPAN> <A name="label10"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Session<SPAN class="keyword">.</SPAN>break&nbsp;</CODE><CODE><I>S</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>Disconnects <CODE><I>S</I></CODE> to whatever other session it was connected to. This is an as soon as possible disconnection: if the communication state was <CODE>ok</CODE> then all sent messages are garanteed to arrive before the disconnection. On the contrary, if the communication was in the <CODE>permFail</CODE> state, the disconnection is immediate and pending messages may be lost in the process. Note that <CODE>break</CODE> is the only way to terminate a session if it goes to <CODE>permFail</CODE> for an infinite amount of time. </P></DD><DT><A name="label11"></A><SPAN class="index"><CODE>getStream</CODE></SPAN> <A name="label12"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Session<SPAN class="keyword">.</SPAN>getStream&nbsp;</CODE><CODE><I>S</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Xs</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns the stream of messages sent by sessions connected to <CODE><I>S</I></CODE>. The returned stream doesn't start from the creation of <CODE><I>S</I></CODE> but from the moment it is asked. For that reason, it is often better to <CODE>getStream</CODE> before connecting to another session, otherwise messages might be lost. </P></DD><DT><A name="label13"></A><SPAN class="index"><CODE>getStateStream</CODE></SPAN> <A name="label14"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Session<SPAN class="keyword">.</SPAN>getStateStream&nbsp;</CODE><CODE><I>S</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Xs</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns the stream of communication states of <CODE><I>S</I></CODE> with the other sessions it is successively connected to. The returned stream doesn't start from the creation of <CODE><I>S</I></CODE>, but from the last known communication state change. So <CODE><I>Xs</I></CODE> has the form <CODE><I>C</I></CODE>|<CODE><I>Cs</I></CODE> where <CODE><I>C</I></CODE> is the current communication state of <CODE><I>S</I></CODE> and <CODE><I>Cs</I></CODE> is the stream that will receive the updates when that state changes. This stream can be composed of one of the following atoms: <CODE>connect</CODE>, <CODE>disconnect</CODE>, <CODE>tempFail</CODE>, <CODE>ok</CODE>, <CODE>permFail</CODE>. </P></DD><DT><A name="label15"></A><SPAN class="index"><CODE>getSideStream</CODE></SPAN> <A name="label16"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Session<SPAN class="keyword">.</SPAN>getSideStream&nbsp;</CODE><CODE><I>S</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Xs</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns the free-for-all stream of <CODE><I>S</I></CODE>. There is no need to connect to <CODE><I>S</I></CODE> to send an element to this stream. The returned stream doesn't start from the creation of <CODE><I>S</I></CODE> but from the moment it is asked. Elements of <CODE><I>Xs</I></CODE> are composed of pairs <CODE>RS<SPAN class="keyword">#</SPAN>M</CODE> where <CODE>RS</CODE> is a reference to the session object used to send the message <CODE>M</CODE>. </P></DD><DT><A name="label17"></A><SPAN class="index"><CODE>getState</CODE></SPAN> <A name="label18"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Session<SPAN class="keyword">.</SPAN>getState&nbsp;</CODE><CODE><I>S</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>T</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns current state of <CODE><I>S</I></CODE>, ie <CODE>{Session<SPAN class="keyword">.</SPAN>getStateStream&nbsp;</CODE><CODE><I>S</I></CODE><CODE>}<SPAN class="keyword">.</SPAN>1</CODE>. </P></DD><DT><A name="label19"></A><SPAN class="index"><CODE>getPeer</CODE></SPAN> <A name="label20"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Session<SPAN class="keyword">.</SPAN>getPeer&nbsp;</CODE><CODE><I>S1</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>S2</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns the session instance <CODE><I>S1</I></CODE> is currently connected with, or <CODE><SPAN class="keyword">unit</SPAN></CODE> if <CODE><I>S1</I></CODE> is not currently connected. </P></DD><DT><A name="label21"></A><SPAN class="index"><CODE>sSend</CODE></SPAN> <A name="label22"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Session<SPAN class="keyword">.</SPAN>sSend&nbsp;</CODE><CODE><I>S</I></CODE><CODE>&nbsp;</CODE><CODE><I>M</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>Sends <CODE><I>M</I></CODE> to the reception stream of the session <CODE><I>S</I></CODE> is connected to in a synchronous way: this command blocks until this message has arrived on the reception stream of the other site. Raises an exception if <CODE><I>S</I></CODE> is not currently connected. </P></DD><DT><A name="label23"></A><SPAN class="index"><CODE>aSend</CODE></SPAN> <A name="label24"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Session<SPAN class="keyword">.</SPAN>aSend&nbsp;</CODE><CODE><I>S</I></CODE><CODE>&nbsp;</CODE><CODE><I>M</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>Sends <CODE><I>M</I></CODE> to the reception stream of the session <CODE><I>S</I></CODE> is connected to. Doesn't block. Raises an exception if <CODE><I>S</I></CODE> is not currently connected. </P></DD><DT><A name="label25"></A><SPAN class="index"><CODE>lSend</CODE></SPAN> <A name="label26"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Session<SPAN class="keyword">.</SPAN>lSend&nbsp;</CODE><CODE><I>S</I></CODE><CODE>&nbsp;</CODE><CODE><I>M</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>Sends <CODE><I>M</I></CODE> to the reception stream of <CODE><I>S</I></CODE> itself. </P></DD><DT><A name="label27"></A><SPAN class="index"><CODE>sideSend</CODE></SPAN> <A name="label28"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Session<SPAN class="keyword">.</SPAN>sideSend&nbsp;</CODE><CODE><I>S1</I></CODE><CODE>&nbsp;</CODE><CODE><I>S2</I></CODE><CODE>&nbsp;</CODE><CODE><I>M</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>Sends <CODE><I>M</I></CODE> to the free-for-all reception stream of <CODE><I>S2</I></CODE>. <CODE><I>S2</I></CODE> receives the pair <CODE>S1<SPAN class="keyword">#</SPAN>M</CODE> on his free-for-all stream. Nothing happens if <CODE><I>S2</I></CODE> is unreachable. </P></DD><DT><A name="label29"></A><SPAN class="index"><CODE>bind</CODE></SPAN> <A name="label30"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Session<SPAN class="keyword">.</SPAN>bind&nbsp;</CODE><CODE><I>S</I></CODE><CODE>&nbsp;</CODE><CODE><I>Event</I></CODE><CODE>&nbsp;</CODE><CODE><I>Proc</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>This procedure provides an event based way of managing communication state changes. <CODE><I>Event</I></CODE> must be one of these atoms: <CODE>connect</CODE>, <CODE>disconnect</CODE>, <CODE>tempFail</CODE>, <CODE>ok</CODE>, <CODE>permFail</CODE>. <CODE><I>Proc</I></CODE> is a zero parameter procedure that is executed each time the state change specified by <CODE><I>Event</I></CODE> occurs on <CODE><I>S</I></CODE>. </P></DD><DT><A name="label31"></A><SPAN class="index"><CODE>configure</CODE></SPAN> <A name="label32"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Session<SPAN class="keyword">.</SPAN>configure&nbsp;</CODE><CODE><I>S</I></CODE><CODE>&nbsp;</CODE><CODE><I>Param</I></CODE><CODE>&nbsp;</CODE><CODE><I>Value</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>Changes the paramater <CODE><I>Param</I></CODE> of <CODE><I>S</I></CODE> to <CODE><I>Value</I></CODE>. Currently, the only configurable parameter is: </P><UL><LI><P><CODE>autoBreakAfter</CODE>: either an integer representing milliseconds, or the atom <CODE>inf</CODE> for an infinite time (default). Specifies a time to wait before automatically breaking a session when a <CODE>permFail</CODE> occurs. </P></LI></UL><P> </P></DD><DT><A name="label33"></A><SPAN class="index"><CODE>isConnected</CODE></SPAN> <A name="label34"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Session<SPAN class="keyword">.</SPAN>isConnected&nbsp;</CODE><CODE><I>S</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>B</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns <CODE><SPAN class="keyword">true</SPAN></CODE> if <CODE><I>S</I></CODE> is currently connected, <CODE><SPAN class="keyword">false</SPAN></CODE> otherwise. </P></DD><DT><A name="label35"></A><SPAN class="index"><CODE>wait</CODE></SPAN> <A name="label36"></A> <A name="label37"></A> <A name="label38"></A> <A name="label39"></A> <A name="label40"></A> <A name="label41"></A> <A name="label42"></A> <A name="label43"></A> <A name="label44"></A> <A name="label45"></A> <A name="label46"></A> <A name="label47"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Session<SPAN class="keyword">.</SPAN>wait[Ok<SPAN class="keyword">|</SPAN>NotOk<SPAN class="keyword">|</SPAN>Connect<SPAN class="keyword">|</SPAN>Disconnect]&nbsp;</CODE><CODE><I>S</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Session<SPAN class="keyword">.</SPAN>wait[Ok<SPAN class="keyword">|</SPAN>NotOk<SPAN class="keyword">|</SPAN>Connect<SPAN class="keyword">|</SPAN>Disconnect]Or&nbsp;</CODE><CODE><I>S</I></CODE><CODE>&nbsp;</CODE><CODE><I>V</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Session<SPAN class="keyword">.</SPAN>wait[Ok<SPAN class="keyword">|</SPAN>NotOk<SPAN class="keyword">|</SPAN>Connect<SPAN class="keyword">|</SPAN>Disconnect]Ors&nbsp;</CODE><CODE><I>S</I></CODE><CODE>&nbsp;</CODE><CODE><I>LV</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>If the communication status of <CODE><I>S</I></CODE> is not in the specified state, then blocks until it is. Supported states are: </P><UL><LI><P><CODE>Ok</CODE> means <CODE><I>S</I></CODE> is connected to another session instance and the link between them is fine. </P></LI><LI><P><CODE>NotOk</CODE> in all situations that are not <CODE>Ok</CODE>. </P></LI><LI><P><CODE>Connect</CODE> means <CODE><I>S</I></CODE> is connected to another session instance. </P></LI><LI><P><CODE>Disconnect</CODE> means <CODE><I>S</I></CODE> is not connected to another session instance. </P></LI></UL><P> The <CODE>Or</CODE> flavour also specifies a logic variable <CODE><I>V</I></CODE> and blocks until the specified state occurs, or <CODE><I>V</I></CODE> is determined. The <CODE>Ors</CODE> flavour also specifies a list logic variable <CODE><I>LV</I></CODE> and blocks until the specified state occurs, or any of the elements of <CODE><I>LV</I></CODE> is determined. </P></DD></DL><P> </P></DIV><DIV id="chapter.reference.gate"><H2><A name="chapter.reference.gate">3.2 Gate Reference</A></H2><P> </P><DL><DT><A name="label48"></A><SPAN class="index"><CODE>isGate</CODE></SPAN> <A name="label49"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Session<SPAN class="keyword">.</SPAN>isGate&nbsp;</CODE><CODE>+<I>X</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>B</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>tests whether <CODE><I>X</I></CODE> is a <CODE>Gate</CODE>. </P></DD><DT><A name="label50"></A><SPAN class="index"><CODE>newGate</CODE></SPAN> <A name="label51"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Session<SPAN class="keyword">.</SPAN>newGate&nbsp;</CODE><CODE>?<I>S</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>G</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>returns a new gate and binds <CODE><I>S</I></CODE> to a list of futures. Each time a connection is created on this gate by <CODE>Session<SPAN class="keyword">.</SPAN>gateConnect</CODE>, the next element of <CODE><I>S</I></CODE> is bound to the local session created for the communication. </P></DD><DT><A name="label52"></A><SPAN class="index"><CODE>gateConnect</CODE></SPAN> <A name="label53"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Session<SPAN class="keyword">.</SPAN>gateConnect&nbsp;</CODE><CODE><I>G</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>S</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>returns a local session <CODE><I>S</I></CODE> connected to a session created by the gate <CODE><I>G</I></CODE>. </P></DD><DT><A name="label54"></A><SPAN class="index"><CODE>closeGate</CODE></SPAN> <A name="label55"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Session<SPAN class="keyword">.</SPAN>closeGate&nbsp;</CODE><CODE><I>G</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>Stops the gate <CODE><I>G</I></CODE> from accepting new connections and closes the associated list of sessions. <CODE><I>G</I></CODE> must be a local gate.</P></DD></DL><P></P></DIV></DIV><HR><UL class="toc"><LI><A href="http://www2.info.ucl.ac.be/people/ned/session/doc/idx.html#label56">Index</A></LI></UL><HR><ADDRESS>Donatien Grolaux<BR><SPAN class="version">Version 1.2.3 (20020111)</SPAN></ADDRESS></BODY></HTML>
