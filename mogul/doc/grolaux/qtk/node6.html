<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>6 Migratable user interface</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node5.html#chapter.advanced">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node7.html#chapter.stddialog">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.migratable"><H1><A name="chapter.migratable">6 Migratable user interface</A></H1><P>QTk provides a transparent mechanism to migrate user interfaces. For the programmer using QTk, there is almost no difference between a migratable user interface and a stationary one. Migratable user interfaces are built using <CODE>QTk<SPAN class="keyword">.</SPAN>buildMigratable</CODE> instead of <CODE>QTk<SPAN class="keyword">.</SPAN>build</CODE>. <CODE>receiver</CODE> widgets can display migratable user interfaces. From the point of view of the developper, there is no differences between using QTk objects built using <CODE>QTk<SPAN class="keyword">.</SPAN>build</CODE> or <CODE>QTk<SPAN class="keyword">.</SPAN>buildMigratable</CODE>, there is just a performance hit because the interface is no more local. Looks and aliases work as usual, they depend only on the site building the migratable widgets, and not at all on the site displaying them. The site displaying a migratable user interface (in a <CODE>receiver</CODE> widget) has no control at all over that user interface. It can only choose to display it (in its entirety) or not at all. Developers can customize the way the state of the user interface is migrated between several sites to 1. enhance performance and 2. ensure fault tolerance.</P><DIV id="misc.migratabletutorial"><H2><A name="misc.migratabletutorial">6.1 Migratable user interface example</A></H2><P>Site A: </P><BLOCKQUOTE class="code"><CODE>P<BR>M={QTk<SPAN class="keyword">.</SPAN>buildMigratable&nbsp;td(label(text:<SPAN class="string">&quot;Migratable&nbsp;user&nbsp;interface&nbsp;demo&quot;</SPAN>)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;placeholder(handle:P))}<BR>{P&nbsp;set(button(text:<SPAN class="string">&quot;Click&nbsp;to&nbsp;button&nbsp;to&nbsp;make&nbsp;it&nbsp;disappear&quot;</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;action:<SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">$</SPAN>}&nbsp;{P&nbsp;set(empty)}&nbsp;<SPAN class="keyword">end</SPAN>))}<BR>Ref={M&nbsp;get(ref:$)}<BR>&nbsp;<BR><SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="comment">%%&nbsp;make&nbsp;Ref&nbsp;available&nbsp;to&nbsp;some&nbsp;other&nbsp;site</SPAN></CODE></BLOCKQUOTE><P> Site B: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="comment">%%&nbsp;get&nbsp;Ref&nbsp;from&nbsp;the&nbsp;other&nbsp;site<BR></SPAN>R<BR>Win={QTk<SPAN class="keyword">.</SPAN>build&nbsp;td(label(text:<SPAN class="string">&quot;Migratable&nbsp;user&nbsp;interface&nbsp;below&quot;</SPAN>)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;receiver(handle:R))}<BR>{R&nbsp;set(Ref)}&nbsp;<SPAN class="comment">%&nbsp;bring&nbsp;the&nbsp;migratable&nbsp;here</SPAN></CODE></BLOCKQUOTE><P></P></DIV><DIV id="misc.migratableinterface"><H2><A name="misc.migratableinterface">6.2 buildMigratable</A></H2><P>Every QTk builders have a <CODE>buildMigratable</CODE> feature similar to their <CODE>build</CODE> feature. <CODE>QTk<SPAN class="keyword">.</SPAN>buildMigratable</CODE> is the <CODE>buildMigratable</CODE> feature of the default builder. Like the <CODE>build</CODE> feature, the parameter is a description of a window, where the toplevel widget is of the type <CODE>td</CODE> or <CODE>lr</CODE>. This toplevel widget supports the same parameters and interface than the <CODE>td</CODE> and <CODE>lr</CODE> widgets. They also implement these two methods: </P><UL><LI><P><CODE>transfertState(Widget&nbsp;Get&nbsp;Set)</CODE>: <CODE>Widget</CODE> is either an atom representing a class of widgets (like <CODE>label</CODE>, <CODE>button</CODE> and so on) or the handle of a widget depending from this migratable user interface. This method defines how <CODE>Widget</CODE> is migrated. To achieve migration between two sites <CODE>A</CODE> and <CODE>B</CODE>, QTk has to transfert the state of each widgets inside the migratable user interface from <CODE>A</CODE> to <CODE>B</CODE>. This is done by grabbing the state of all the widgets from <CODE>A</CODE>, then create all these widgets on <CODE>B</CODE> and set their states back to what they where on <CODE>A</CODE>. By default, these operations are defined to transfert every parameter possible of all widgets. There are two drawbacks however: 1. it is inefficient as the whole state of the widgets are transfered, and not only those states that can be changed (by the user or the application) and 2. if the site displaying the user interface crashes, the state is completely lost. Consequently, it is advised to redefine these two operations, by providing for all widgets these two procedures: </P><UL><LI><P><CODE>{Get&nbsp;Widget&nbsp;?Ret}</CODE>: this procedure must bind <CODE>Ret</CODE> to a data structure representing the state of the widget whose handle is <CODE>Widget</CODE>.</P></LI><LI><P><CODE>{Set&nbsp;Widget&nbsp;State&nbsp;Resources&nbsp;AssignResource}</CODE>: this procedure must set the widget whose handle is <CODE>Widget</CODE> to the state <CODE>State</CODE>. The canvas and text widgets can create objects considered as <EM>resources</EM>: canvas tags and handle; text tags and marks. When migrating, these resources have to be created again on the site where the user interface is migrated to. The <CODE>Resources</CODE> parameter is a list of all the resources that where created by <CODE>Widget</CODE>, as a list of pairs of the type: </P><UL><LI><P><CODE>ct<SPAN class="keyword">#</SPAN>CanvasTag</CODE> where <CODE>CanvasTag</CODE> is a canvas tag.</P></LI><LI><P><CODE>ch<SPAN class="keyword">#</SPAN>CanvasHandle</CODE> where <CODE>CanvasHandle</CODE> is a canvas handle.</P></LI><LI><P><CODE>tt<SPAN class="keyword">#</SPAN>TextTag</CODE> where <CODE>TextTag</CODE> is a text tag.</P></LI><LI><P><CODE>tm<SPAN class="keyword">#</SPAN>TextMark</CODE> where <CODE>TextMark</CODE> is a text mark.</P></LI></UL><P> The <CODE>Set</CODE> procedure has to issue commands to create back these resources. The <CODE>AssignResource</CODE> function creates a distinction between the use of a resource (<CODE>Resource</CODE>) and its creation (<CODE>{AssignResource&nbsp;Resource}</CODE>) so that QTk knows the remote site is creating a resource that should be linked to the already known <CODE>Resource</CODE> object. For example for a text widget, the set method should typically do the following: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">Set</SPAN>&nbsp;Widget&nbsp;State&nbsp;Resource&nbsp;AssignResource}<BR>&nbsp;&nbsp;&nbsp;{ForAll&nbsp;Resource<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;T<SPAN class="keyword">#</SPAN>R}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;T&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;tt&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{Widget&nbsp;newTag({AssignResource&nbsp;R})}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;tm&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{Widget&nbsp;newMark({AssignResource&nbsp;R})}<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>}<BR><SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="comment">%%&nbsp;sets&nbsp;back&nbsp;the&nbsp;state&nbsp;of&nbsp;Widget&nbsp;according&nbsp;to&nbsp;State.&nbsp;This&nbsp;part&nbsp;can&nbsp;use&nbsp;directly&nbsp;the&nbsp;tags&nbsp;and&nbsp;marks&nbsp;created&nbsp;right&nbsp;above.<BR></SPAN><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P></P></LI></UL><P> Note that before the application of <CODE>Set</CODE>, all widgets are in the state they where right after their construction from their initial description record. If a widget is never changed (by the user or the application) after its creation, you can safely set their <CODE>Set</CODE> method to return unit and their <CODE>Get</CODE> method to skip. To make an application completely fault tolerant, the safest method is to redefine the <CODE>Set</CODE> and <CODE>Get</CODE> functions of every displayed widgets so that the <CODE>Get</CODE> procedure relies only on the inner state of the application, and not at all from the result of the <CODE>Set</CODE> function. For example: </P><BLOCKQUOTE class="code"><CODE>C<BR>M={QTk<SPAN class="keyword">.</SPAN>buildMigratable&nbsp;td(canvas(handle:C))}<BR>&nbsp;<BR>Data={NewCell&nbsp;nil}<BR><SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">DrawCircle</SPAN>&nbsp;X1&nbsp;Y1&nbsp;X2&nbsp;Y2}<BR>&nbsp;&nbsp;&nbsp;{Assign&nbsp;Data&nbsp;X1<SPAN class="keyword">#</SPAN>Y1<SPAN class="keyword">#</SPAN>X2<SPAN class="keyword">#</SPAN>Y2<SPAN class="keyword">|</SPAN>{Access&nbsp;Data}}<BR>&nbsp;&nbsp;&nbsp;{C&nbsp;create(oval&nbsp;X1&nbsp;Y1&nbsp;X2&nbsp;Y2)}<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;<BR>{M&nbsp;transfertState(C&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">fun</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;_}&nbsp;<SPAN class="keyword">unit</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<SPAN class="comment">%%&nbsp;dummy&nbsp;get<BR></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;W&nbsp;_&nbsp;_}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="comment">%%&nbsp;set&nbsp;relies&nbsp;on&nbsp;inner&nbsp;state&nbsp;of&nbsp;the&nbsp;application&nbsp;only<BR></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ForAll&nbsp;{Reverse&nbsp;Data}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;X1<SPAN class="keyword">#</SPAN>Y1<SPAN class="keyword">#</SPAN>X2<SPAN class="keyword">#</SPAN>Y2}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{W&nbsp;create(oval&nbsp;X1&nbsp;Y1&nbsp;X2&nbsp;Y2)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>)}<BR>&nbsp;<BR>{DrawCircle&nbsp;10&nbsp;10&nbsp;100&nbsp;100}<BR>{DrawCircle&nbsp;20&nbsp;20&nbsp;40&nbsp;40}</CODE></BLOCKQUOTE><P></P></LI><LI><P><CODE>updateState</CODE>: updates the states of all the widgets of the migratable user interface. This is normally automatically done before migrating from a site. If ever the site displaying the user interface fails (preventing QTk from accessing the latest state of the user interface), the state used would be the latest state stored by an <CODE>updateState</CODE> call. For some user interfaces (for example those that present as a filling form), <CODE>updateState</CODE> at the right moment might be enough to ensure enough fault tolerance.</P></LI><LI><P><CODE>updateState(W)</CODE>: updates the state of the widget <CODE>W</CODE> (and only this one).</P></LI><LI><P><CODE>updateState(W&nbsp;?R)</CODE>: updates the state of the widget <CODE>W</CODE> (and only this one) and binds <CODE>R</CODE> to this state.</P></LI></UL><P> </P></DIV></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node5.html#chapter.advanced">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node7.html#chapter.stddialog">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS>Donatien Grolaux<BR><SPAN class="version">Version 1.2.3 (20020111)</SPAN></ADDRESS></BODY></HTML>
