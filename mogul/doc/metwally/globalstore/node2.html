<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>2 GlobalStore Module Application Programming Interface</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node1.html#chapter.introduction">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node3.html#chapter.agents">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.api"><H1><A name="chapter.api">2 <CODE>GlobalStore</CODE> Module Application Programming Interface</A></H1><P> The interface functions to use the <CODE>GlobalStore</CODE> module are the following: </P><DIV id="section.globalstore.newgs"><H2><A name="section.globalstore.newgs">2.1 Initialise a new global store (GS) and connect to GS</A></H2><P> </P><DL><DT><A name="label1"></A><SPAN class="index"><CODE>GlobalStore<SPAN class="keyword">.</SPAN>newStore</CODE></SPAN> <A name="label2"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>{GlobalStore<SPAN class="keyword">.</SPAN>newStore&nbsp;?BootLocalStore}</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DT><A name="label3"></A><SPAN class="index"><CODE>newLocal</CODE></SPAN> <A name="label4"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>{BootLocalStore&nbsp;newLocal(Module&nbsp;UserName&nbsp;?NewObj&nbsp;?LocalStore&nbsp;?MoveHere)}</CODE></BLOCKQUOTE><P> </P><BLOCKQUOTE class="code"><CODE>{LocalStore&nbsp;newLocal(Module&nbsp;UserName1&nbsp;?NewObj1&nbsp;?LocalStore1&nbsp;?MoveHere1)}</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>Creates a new global store together with a procedure <CODE>BootLocalStore</CODE> which can be used to create local stores on different sites. A local store is a single site's reference into the global store. </P><UL><LI><P>the <CODE>BootLocalStore</CODE> and <CODE>LocalStore</CODE> calls can be executed on any site. </P></LI><LI><P>A <CODE>LocalStore</CODE> created by one of these calls can itself create more LocalStores, and so forth recursively. That is, the creation of LocalStores is fully distributed. </P></LI><LI><P><CODE>LocalStore</CODE> is sited except for the <CODE>newLocal</CODE> method , which can be executed on any site. </P></LI><LI><P><CODE>NewObj</CODE> is a sited reference; it can be executed only on the site on which it was created. </P></LI><LI><P><CODE>MoveHere</CODE> is a non-sited reference; it can be executed on any site </P></LI><LI><P>The call <CODE>newStore</CODE> throws a <CODE>gs(failed_globalstore_creation)</CODE> exception when no global store is created. </P></LI><LI><P>The call <CODE>newLocal</CODE> throws a <CODE>gs(connectionfailed)</CODE> exception if it fails to connect to the global store. </P></LI><LI><P><CODE>UserName</CODE> is an atom or a string identifying a user and <CODE>Module</CODE> is the ressource Module Manager in the system.</P></LI></UL><P></P></DD></DL><P> </P></DIV><DIV id="section.globalstore.newobj"><H2><A name="section.globalstore.newobj">2.2 Create new objects in the GS</A></H2><P> </P><DL><DT><A name="label5"></A><SPAN class="index"><CODE>NewObj</CODE></SPAN> <A name="label6"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>O={NewObj&nbsp;Class&nbsp;Init}</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>Add a new object <CODE>O</CODE> to the store. The call <CODE>NewObj</CODE> is synchronous. <CODE>O</CODE> is an object reference in the global store.The new object is immediately broadcast to the other clients. If there is a failure, then the new object will survive if at least one surviving client contains the new object. <CODE>Class</CODE> is any Oz class with the following restrictions: </P><UL><LI><P>no reference to ressources. </P></LI><LI><P>no references to external states i.e. logic variables, cells, objects including global store object references. In the next release of Mozart, global store object can have references to other global store objects. </P></LI></UL><P> </P></DD></DL><P></P></DIV><DIV id="section.globalstore.trans"><H2><A name="section.globalstore.trans">2.3 Initialise new transactions</A></H2><P>The user interacts with the global store by using transactions: </P><DL><DT><A name="label7"></A><SPAN class="index"><CODE>trans</CODE></SPAN> <A name="label8"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>{LocalStore&nbsp;trans(Trans&nbsp;?OutPut&nbsp;?Transid)}</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>Initialises a transaction <CODE>Trans</CODE> which is a procedure of one argument. The argument <CODE>Output</CODE> is a computed return value in <CODE>Trans</CODE>. A <CODE>gs(ill_formed_transaction)</CODE> is raised when <CODE>Trans</CODE> is not a one argument procedure. The procedure must have the following properties: </P><UL><LI><P>Transactions have no external references to: objects, cells, variables and global store objects. </P></LI><LI><P>At a single user, execution of transactions are serialized. </P></LI></UL><P> </P></DD></DL><P> </P><DIV id="section.globalstore.inside"><H3><A name="section.globalstore.inside">2.3.1 Calls inside transactions</A></H3><P>These functions are only used inside a transaction. If one of this function is called outside a transaction the exception <CODE>gs(invalidcall)</CODE> is raised. </P><DL><DT><A name="label9"></A><SPAN class="index"><CODE>apply&nbsp;a&nbsp;method&nbsp;on&nbsp;an&nbsp;object</CODE></SPAN> <A name="label10"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>{O&nbsp;Meth}</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P><CODE>O</CODE> is a reference to an object in the store. </P></DD><DT><A name="label11"></A><SPAN class="index"><CODE>waitlocks</CODE></SPAN> <A name="label12"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>{LocalStore&nbsp;waitlocks(Objects)}</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>Wait for locks on <CODE>Objects</CODE>: If the locks are not obtained the transaction is aborted. </P></DD><DT><A name="label13"></A><SPAN class="index"><CODE>newthread</CODE></SPAN> <A name="label14"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>{LocalStore&nbsp;newthread(Proc)}</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>The call <CODE>newthread</CODE> inside a transaction procedure executes <CODE>Proc</CODE> of 0 arguments in a separate thread. </P></DD><DT><A name="label15"></A><SPAN class="index"><CODE>retrans</CODE> </SPAN> <A name="label16"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>{LocalStore&nbsp;retrans(Proc&nbsp;&nbsp;?Output&nbsp;?ReTransid)}</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>The call <CODE>retrans</CODE> confirms all updates of the transaction <CODE>Transid</CODE> that have already committed without waiting its end. The initial transaction <CODE>Transid</CODE> is mapped to a new transaction <CODE>ReTransid</CODE>. Initially, the new transaction has the set of <CODE>Transid</CODE> objects. </P></DD></DL><P> </P></DIV></DIV><DIV id="section.globalstore.check"><H2><A name="section.globalstore.check">2.4 Check transactions</A></H2><P> The user checks the states of transaction by the following call </P><DL><DT><A name="label17"></A><SPAN class="index"><CODE>checktrans</CODE></SPAN> <A name="label18"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>{LocalStore&nbsp;checktrans(Transid&nbsp;?Res&nbsp;?Nb)}</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>Checks if a transaction was committed or aborted. <CODE>Res</CODE> is a <CODE>commit</CODE>, <CODE>abort</CODE> atom or is a free variable that will be bound as soon as the transaction receives <CODE>abort</CODE> or <CODE>commit</CODE>. Since the computation of a transaction is speculative, it is useful to know the number of time <CODE>Nb</CODE> that the <CODE>Transid</CODE> is recomputed. </P></DD></DL><P></P></DIV><DIV id="section.globalstore.deleteobj"><H2><A name="section.globalstore.deleteobj">2.5 Delete Object from GlobalStore</A></H2><P> The user delete an object from GolbalStore by the following call </P><DL><DT><A name="label19"></A><SPAN class="index"><CODE>deleteobj</CODE></SPAN> <A name="label20"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>{LocalStore&nbsp;deleteobj(ObjRef&nbsp;?Res)}</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>This call will successfully delete an object from the store if it can obtain the lock.<CODE>Res</CODE> is a <CODE>commit</CODE>, <CODE>abort</CODE> atom or is a free variable that will be bound as soon as the transaction receives <CODE>abort</CODE> or <CODE>commit</CODE>. </P></DD></DL><P></P></DIV><DIV id="section.globalstore.disconnect"><H2><A name="section.globalstore.disconnect">2.6 Disconnect from GlobalStore</A></H2><P> The user can disconnect normally from GolbalStore by the following call </P><DL><DT><A name="label21"></A><SPAN class="index"><CODE>disconnect</CODE></SPAN> <A name="label22"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>{LocalStore&nbsp;disconnect}</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>This call will successfully disconnect the caller from Globalstore. This call will change the current membership, and every member in GS will be notified about the latest membership. </P></DD></DL><P></P></DIV><DIV id="section.globalstore.migrate"><H2><A name="section.globalstore.migrate">2.7 Global Store migration</A></H2><P> we can migrate the global store by calling the <CODE>MoveHere</CODE> procedure. The <CODE>MoveHere</CODE> procedure is returned by the <CODE>newLocal</CODE> call. </P><DL><DT><A name="label23"></A><SPAN class="index"><CODE>MoveHere</CODE></SPAN> <A name="label24"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>{MoveHere&nbsp;Module&nbsp;LocalStore&nbsp;Proc}</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>The call migrates the global store to the site where the one argument <CODE>MoveHere</CODE> procedure is executed. <CODE>LocalStore</CODE> is a returned sited reference to the store in the site where the call <CODE>MoveHere</CODE> is executed. <CODE>Module</CODE> is the ressource Module Manager in the system. <CODE>Proc</CODE> is a user defined zero argument procedure. <CODE>Proc</CODE> is executed in the site where the call <CODE>MoveHere</CODE> is executed. </P></DD></DL><P> </P></DIV><DIV id="section.globalstore.outside"><H2><A name="section.globalstore.outside">2.8 Notification methods</A></H2><P> To communicate with user applications, the global store offers notify procedures are of three kinds: Creation, Update, and Delete procedures. Creation procedures are called upon creation of a GlobalStore object. Update procedures are called whenever the state of a GlobalStore object is changed coherently. Delete procedures are called whenever a GlobalStore object is deleted. One Creation, Update, or Delete procedure can be installed per client and per object. A Notify procedure installed by a client will be executed only by that client on that client's site. functions to notify a user for a creation of a new object and for object update in the GS. Notify procedures must respect the following rules: </P><UL><LI><P>A Notify procedure can use in any way any language entity outside of the GlobalStore, e.g., resources, ports, cells, or objects that are not part of the GlobalStore. There are no restrictions. </P></LI><LI><P>A Notify procedure is given a coherent view of the GlobalStore, and it may call GlobalStore objects in any way. However, any changes done by these calls will be canceled after the Notify procedure exits. </P></LI><LI><P>The execution of a Notify procedure is serialized with transaction executions at a client. Therefore, the Notify procedure should not be too time-consuming, as this will delay the execution of transactions at that client. </P></LI><LI><P>A Notify procedure may initiate transactions, but it should not wait until a transaction completes. Otherwise, deadlock will occur. </P></LI><LI><P>A Notify procedure must use {LocalStore newThread(P)} to create new threads. The system considers then that the Notify procedure completes when all these threads complete. </P></LI><LI><P>A Notify procedure *may* use thread S end, but only if S refers to no GlobalStore objects and does no transactions. This ability should be used with extreme care: in most cases, newThread(P) should be used.</P></LI></UL><P> </P><DL><DT><A name="label25"></A><SPAN class="index"><CODE>setnotifycreation</CODE></SPAN> <A name="label26"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>{LocalStore&nbsp;setnotifycreation(Proc)}</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P><CODE>Proc</CODE> is a user defined one argument procedure executed when another user creates a new object in the global store. <CODE>Proc</CODE> is executed on all remote local stores. The argument of <CODE>Proc</CODE> is a reference to the new object in the store. </P></DD><DT><A name="label27"></A><SPAN class="index"><CODE>setnotifyupdate</CODE></SPAN> <A name="label28"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>{LocalStore&nbsp;setnotifyupdate(Proc)}</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P><CODE>Proc</CODE> is a user defined one argument procedure executed when an object in the global store is updated by other users. <CODE>Proc</CODE> is executed on all remote local stores. The argument of <CODE>Proc</CODE> is a reference to the updated GS object. </P></DD><DT><A name="label29"></A><SPAN class="index"><CODE>setnotifydelete</CODE></SPAN> <A name="label30"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>{LocalStore&nbsp;setnotifydelete(Proc)}</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P><CODE>Proc</CODE> is a user defined one argument procedure executed when an object in the global store is deleted by other users. <CODE>Proc</CODE> is executed on all remote local stores. The argument of <CODE>Proc</CODE> is a reference to the deleted GS object. </P></DD><DT><A name="label31"></A><SPAN class="index"><CODE>setnotifyabort</CODE></SPAN> <A name="label32"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>{LocalStore&nbsp;setnotifyabort(Proc)}</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P><CODE>Proc</CODE> is a user defined one argument procedure executed when restoring the state of a GS object after a transaction abort. <CODE>Proc</CODE> is executed on the current local store only. The argument of <CODE>Proc</CODE> is a reference to a GS object of the aborted transaction. setactionmyacount(P)</P></DD><DT><A name="label33"></A><SPAN class="index"><CODE>setnotifymembership</CODE></SPAN> <A name="label34"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>{LocalStore&nbsp;setnotifymembership(Proc)}</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P><CODE>Proc</CODE> is a user defined one argument procedure executed when there is a change in the memership (user connected, or disconnected). the argument of this Proc will be the list of current membership (username1#id1,...usernmaen#idn). </P></DD><DT><A name="label35"></A><SPAN class="index"><CODE>setnotifymyacount</CODE></SPAN> <A name="label36"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>{LocalStore&nbsp;setnotifymyacount(Proc)}</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P><CODE>Proc</CODE> is a user defined one argument procedure executed when the user is connected to GlobalStore. the argument of this Proc will be the user's account (username#id) </P></DD><DT><A name="label37"></A><SPAN class="index"><CODE>setnotifyrecovery</CODE></SPAN> <A name="label38"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>{LocalStore&nbsp;setnotifyrecovery(Proc)}</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P><CODE>Proc</CODE> is a user defined zero argument procedure executed when there is a recovery after server's failure and this will only executed at the leader site. Every user must set this setnotifyrecovery. </P></DD></DL><P> </P></DIV><DIV id="section.globalstore.obj"><H2><A name="section.globalstore.obj">2.9 Export/Import GS object references</A></H2><P> Currently, global store object references are exported and imported using <CODE>saveobj</CODE> and <CODE>getobj</CODE> functions. In the next release, those references will have the distribution transparency property i.e. GS references like classic Oz objects references will be non-sited references. </P><DL><DT><A name="label39"></A><SPAN class="index"><CODE>saveobj</CODE></SPAN> <A name="label40"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>{LocalStore&nbsp;&nbsp;saveobj(Obj&nbsp;?N)}</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P><CODE>N</CODE> is a name (constant) that can be passed external to the global store. </P></DD><DT><A name="label41"></A><SPAN class="index"><CODE>loadobj</CODE></SPAN> <A name="label42"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>{LocalStore&nbsp;&nbsp;loadobj(N&nbsp;?Obj)}</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P><CODE>N</CODE> is the name that contains the global object reference already created at another user. <CODE>Obj</CODE> is a the reference to the <CODE>N</CODE> at the store <CODE>LocalStore</CODE>. if the imported object is lost, a <CODE>gs(objectlost)</CODE> exception is raised. All transactional calls on <CODE>N</CODE> objects from other users give a <CODE>gs(invalidcall)</CODE> exception. </P></DD></DL><P> </P></DIV></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node1.html#chapter.introduction">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node3.html#chapter.agents">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS>Mostafa AL-Metwally, Ilies Alouini <BR><SPAN class="version">Version 1.2.0 (20010319)</SPAN></ADDRESS></BODY></HTML>
