<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>4 Tutorial Examples</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node3.html#chapter.agents">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node5.html#chapter.demos">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.examples"><H1><A name="chapter.examples">4 Tutorial Examples</A></H1><H2><A name="label43">4.1  Create a global store </A></H2><P> The following code shows how to create a new Global Store GS. The imported module <CODE>GlobalStore</CODE> implements the GS abstraction. The procedure <CODE>NewStore</CODE> from the <CODE>GlobalStore</CODE> module initialises a GS and offers the <CODE>Ls</CODE> reference in a file or a URL. </P><P class="margin"><A href="p1.oz">Source File</A></P><P> </P><BLOCKQUOTE><PRE><SPAN class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%<BR>%&nbsp;Create&nbsp;a&nbsp;new&nbsp;global&nbsp;store<BR>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%<BR></SPAN><SPAN class="keyword">functor</SPAN>&nbsp;<BR><SPAN class="keyword">import</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;GlobalStore(newStore:NewStore)&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;Connection<BR>&nbsp;&nbsp;&nbsp;Pickle<BR>&nbsp;&nbsp;&nbsp;System(show:Show)<BR><SPAN class="keyword">define</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;Ls<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">try</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{NewStore&nbsp;?Ls}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="comment">%&nbsp;pickle&nbsp;LS&nbsp;and&nbsp;offer&nbsp;it&nbsp;to&nbsp;clients<BR></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Pickle<SPAN class="keyword">.</SPAN>save&nbsp;{Connection<SPAN class="keyword">.</SPAN>offerUnlimited&nbsp;Ls&nbsp;$}&nbsp;<SPAN class="string">'./gsticket'</SPAN>}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">catch</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gs(failed_globalstore_creation)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Show&nbsp;errorNewStore&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;error(url(_&nbsp;_)&nbsp;debug:_)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{Show&nbsp;<SPAN class="string">'cannot&nbsp;create&nbsp;url&nbsp;or&nbsp;file&nbsp;'</SPAN>}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;error(connection(_&nbsp;_)&nbsp;&nbsp;debug:_)&nbsp;&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{Show&nbsp;<SPAN class="string">'connection&nbsp;Module&nbsp;error'</SPAN>}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR></PRE></BLOCKQUOTE><P></P><H2><A name="label44">4.2  Create a new connected user to the GS </A></H2><P>The following functor creates a new user named <CODE>user1</CODE> connected to the GS. The <CODE>newLocal</CODE> method returns a <CODE>LocalStore</CODE> reference to the GS and a <CODE>NewObj</CODE> procedure for creating new objects in the GS. The call throws a <CODE>gs(connectionfailed)</CODE> exception if it fails to connect to GS. In the current release of the GS module, <CODE>NewObj</CODE> is a sited reference i.e it cannot be exported to others users. Each new user will create its own <CODE>NewObj</CODE> reference. Each user has the ability of creating other users by exporting its <CODE>LocalStore</CODE> reference on distant sites. </P><P class="margin"><A href="p2.oz">Source File</A></P><P> </P><BLOCKQUOTE><PRE><SPAN class="keyword">functor</SPAN>&nbsp;&nbsp;<BR><SPAN class="keyword">import</SPAN>&nbsp;<BR>&nbsp;&nbsp;Connection<BR>&nbsp;&nbsp;System(show:Show)<BR>&nbsp;&nbsp;Pickle<BR><SPAN class="keyword">define</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;LS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">try</SPAN>&nbsp;LS={Connection<SPAN class="keyword">.</SPAN>take&nbsp;{Pickle<SPAN class="keyword">.</SPAN>load&nbsp;<SPAN class="string">'./gsticket'</SPAN>&nbsp;$}}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">catch</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;error(url(_&nbsp;_)&nbsp;debug:_)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{Show&nbsp;<SPAN class="string">'url&nbsp;or&nbsp;file&nbsp;not&nbsp;found'</SPAN>}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;error(connection(_&nbsp;_)&nbsp;&nbsp;debug:_)&nbsp;&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{Show&nbsp;connectionfailed}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;NewObj&nbsp;LocalStore&nbsp;Movehere<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">try</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{LS&nbsp;newLocal(Module&nbsp;user1&nbsp;&nbsp;?NewObj&nbsp;?LocalStore&nbsp;?Movehere)}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">catch</SPAN>&nbsp;gs(connectionfailed)<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Show&nbsp;connectionfailed}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">try</SPAN>&nbsp;{Pickle<SPAN class="keyword">.</SPAN>save&nbsp;{Connection<SPAN class="keyword">.</SPAN>offerUnlimited&nbsp;LocalStore&nbsp;$}&nbsp;<SPAN class="string">'./client1ticket'</SPAN>}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">catch</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;error(url(_&nbsp;_)&nbsp;debug:_)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{Show&nbsp;<SPAN class="string">'cannot&nbsp;create&nbsp;url&nbsp;or&nbsp;file&nbsp;'</SPAN>}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;error(connection(_&nbsp;_)&nbsp;&nbsp;debug:_)&nbsp;&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{Show&nbsp;<SPAN class="string">'connection&nbsp;Module&nbsp;error'</SPAN>}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR></PRE></BLOCKQUOTE><P></P><H2><A name="label45">4.3  Create objects in the global store </A></H2><P> We show how to create three counter objects in the global store:</P><P class="margin"><A href="p3.oz">Source File</A></P><P> </P><BLOCKQUOTE><PRE><SPAN class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%<BR>%%&nbsp;Create&nbsp;an&nbsp;object&nbsp;in&nbsp;the&nbsp;store<BR>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%<BR>%&nbsp;Obj1&nbsp;Obj2&nbsp;Obj3&nbsp;are&nbsp;references&nbsp;in<BR>%&nbsp;&nbsp;the&nbsp;local&nbsp;&nbsp;store&nbsp;&nbsp;<BR>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%<BR></SPAN><SPAN class="keyword">declare</SPAN>&nbsp;<BR><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">Counter</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">attr</SPAN>&nbsp;val<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">show</SPAN>(Value)&nbsp;Value=<SPAN class="keyword">@</SPAN>val&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">inc</SPAN>(Value)&nbsp;val&nbsp;<SPAN class="keyword">&lt;-</SPAN>&nbsp;<SPAN class="keyword">@</SPAN>val<SPAN class="keyword">+</SPAN>Value&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">init</SPAN>(Value)&nbsp;val&nbsp;<SPAN class="keyword">&lt;-</SPAN>&nbsp;Value&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;&nbsp;&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR>Obj1&nbsp;Obj2&nbsp;Obj3<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>Obj1={NewObj&nbsp;&nbsp;Counter&nbsp;init(0)}<BR>Obj2={NewObj&nbsp;&nbsp;Counter&nbsp;&nbsp;init(0)}<BR>Obj3={NewObj&nbsp;&nbsp;Counter&nbsp;&nbsp;init(0)}<BR><SPAN class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%<BR>%%&nbsp;Save&nbsp;&nbsp;Obj1&nbsp;reference&nbsp;to&nbsp;use&nbsp;it&nbsp;on&nbsp;other&nbsp;users<BR>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%<BR>%{LocalStore&nbsp;saveobj(Obj1&nbsp;'obj1')}<BR></SPAN></PRE></BLOCKQUOTE><P></P><H2><A name="label46">4.4  Initialise transactions </A></H2><P> A transaction is a one argument procedure initiated in its own thread. The variable <CODE>Out</CODE> is a return value of <CODE>Trans</CODE>. </P><P class="margin"><A href="p5.oz">Source File</A></P><P> </P><BLOCKQUOTE><PRE><SPAN class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%<BR>%&nbsp;Initialise&nbsp;transactions<BR>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%<BR></SPAN><SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">Trans</SPAN>&nbsp;Out}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;{IsOdd&nbsp;{Obj1&nbsp;show($)}}&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Obj1&nbsp;inc(1)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Obj1&nbsp;inc(<SPAN class="keyword">~</SPAN>1)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Obj2&nbsp;inc(<SPAN class="keyword">~</SPAN>1)}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Obj2&nbsp;inc(2)}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">skip</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;Out=state({Obj1&nbsp;show($)})<BR><SPAN class="keyword">end</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;<BR>OutPut&nbsp;&nbsp;<SPAN class="comment">%&nbsp;Output&nbsp;of&nbsp;Trans<BR></SPAN>Transid&nbsp;<SPAN class="comment">%&nbsp;Transaction&nbsp;Identifier<BR></SPAN><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;{LocalStore&nbsp;trans(Trans&nbsp;?OutPut&nbsp;?Transid)}&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="comment">%%%%&nbsp;check&nbsp;transaction<BR></SPAN>&nbsp;&nbsp;&nbsp;<SPAN class="comment">%%%%&nbsp;The&nbsp;result&nbsp;is&nbsp;commit,&nbsp;abort&nbsp;&nbsp;<BR></SPAN>&nbsp;&nbsp;&nbsp;{System<SPAN class="keyword">.</SPAN>show&nbsp;{LocalStore&nbsp;checktrans(Transid&nbsp;$)}}<BR></PRE></BLOCKQUOTE><P></P><H2><A name="label47">4.5  Coherent Snapshot of the store </A></H2><P> We use a transaction to have values of objects GS values. The values are globally coherent if <CODE>Trans</CODE> is committed. </P><P class="margin"><A href="p4.oz">Source File</A></P><P> </P><BLOCKQUOTE><PRE><SPAN class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%<BR>%&nbsp;Procedure&nbsp;to&nbsp;show&nbsp;a&nbsp;coherent<BR>%&nbsp;snapshot&nbsp;of&nbsp;the&nbsp;global&nbsp;store<BR>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%<BR></SPAN><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">CoherentSnapshot</SPAN>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">Trans</SPAN>&nbsp;?Output}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Val1&nbsp;Val2&nbsp;Val3&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Obj1&nbsp;show(Val1)}&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Obj2&nbsp;show(Val2)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Obj3&nbsp;show(Val3)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Output=state(Val1&nbsp;Val2&nbsp;Val3)<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;Transid<BR>&nbsp;&nbsp;&nbsp;Out<BR>&nbsp;&nbsp;&nbsp;Result<BR><SPAN class="keyword">in</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;{LocalStore&nbsp;trans(Trans&nbsp;?Out&nbsp;?Transid)}<BR>&nbsp;&nbsp;&nbsp;{LocalStore&nbsp;checktrans(Trid&nbsp;Result&nbsp;_)}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;Result<SPAN class="keyword">==</SPAN>commit&nbsp;&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Show&nbsp;<SPAN class="string">'Obj1:'</SPAN><SPAN class="keyword">#</SPAN>Out<SPAN class="keyword">.</SPAN>1<SPAN class="keyword">#</SPAN><SPAN class="string">'Obj2:'</SPAN><SPAN class="keyword">#</SPAN>Out<SPAN class="keyword">.</SPAN>2<SPAN class="keyword">#</SPAN><SPAN class="string">'Obj3:'</SPAN><SPAN class="keyword">#</SPAN>Out<SPAN class="keyword">.</SPAN>3}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">skip</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;&nbsp;&nbsp;<BR></PRE></BLOCKQUOTE><P></P><H2><A name="label48">4.6  Concurrent updates inside a transaction</A></H2><P> We introduce concurrency inside a transaction at a user by the call <CODE>{LocalStore&nbsp;newthread(<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>}&nbsp;{Obj1&nbsp;inc(1)}&nbsp;<SPAN class="keyword">end</SPAN>)}</CODE>. The call executes the procedure <CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>}&nbsp;{Obj1&nbsp;inc(1)}&nbsp;<SPAN class="keyword">end</SPAN></CODE> in its own thread. </P><P class="margin"><A href="p8.oz">Source File</A></P><P> </P><BLOCKQUOTE><PRE><SPAN class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%<BR>%&nbsp;Initialise&nbsp;transactions<BR>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%<BR></SPAN><SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">Trans</SPAN>&nbsp;Out}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;{Obj1&nbsp;inc(1)}<BR>&nbsp;&nbsp;&nbsp;{Obj1&nbsp;inc(<SPAN class="keyword">~</SPAN>1)}<BR>&nbsp;&nbsp;&nbsp;{Obj2&nbsp;inc(<SPAN class="keyword">~</SPAN>1)}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="comment">%%%&nbsp;Update&nbsp;is&nbsp;done&nbsp;in&nbsp;a&nbsp;new&nbsp;thread<BR></SPAN>&nbsp;&nbsp;&nbsp;{LocalStore&nbsp;newthread(<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>}&nbsp;&nbsp;{Obj1&nbsp;inc(1)}&nbsp;<SPAN class="keyword">end</SPAN>)}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="comment">%%%%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR></SPAN>&nbsp;&nbsp;&nbsp;{Obj2&nbsp;inc(2)}<BR>&nbsp;&nbsp;&nbsp;{Obj1&nbsp;inc(1)}<BR>&nbsp;&nbsp;&nbsp;Out=state({Obj1&nbsp;show($)})<BR><SPAN class="keyword">end</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;<BR>OutPut&nbsp;&nbsp;<SPAN class="comment">%&nbsp;Output&nbsp;of&nbsp;Trans<BR></SPAN>Transid&nbsp;<SPAN class="comment">%&nbsp;Transaction&nbsp;Identifier<BR></SPAN>Res<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;{LocalStore&nbsp;trans(Trans&nbsp;OutPut&nbsp;?Transid)}&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="comment">%%%%&nbsp;check&nbsp;transaction<BR></SPAN>&nbsp;&nbsp;&nbsp;<SPAN class="comment">%%%%&nbsp;The&nbsp;result&nbsp;is&nbsp;commit,&nbsp;abort&nbsp;&nbsp;<BR></SPAN>&nbsp;&nbsp;&nbsp;{LocalStore&nbsp;checktrans(Transid&nbsp;Res&nbsp;_)}<BR>&nbsp;&nbsp;&nbsp;{System<SPAN class="keyword">.</SPAN>show&nbsp;Res}<BR>&nbsp;<BR></PRE></BLOCKQUOTE><P></P><H2><A name="label49">4.7  Synchonous waiting for object locks</A></H2><P> To avoid speculative computations, we offer a synchronization procedure to wait for locks on GS objects. If a user has a lock on a GS object say <CODE>O</CODE>, all its local modifications on <CODE>O</CODE> become global (broadcasted to all users). Here is an example of transaction that waits for <CODE>Obj1</CODE> and <CODE>Obj2</CODE> locks before performing the updates. </P><P class="margin"><A href="p9.oz">Source File</A></P><P> </P><BLOCKQUOTE><PRE><SPAN class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%<BR>%&nbsp;Initialise&nbsp;transactions<BR>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%<BR></SPAN><SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">Trans</SPAN>&nbsp;Out}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="comment">%&nbsp;Synchronous&nbsp;waiting&nbsp;for&nbsp;locks&nbsp;on&nbsp;Obj1&nbsp;Obj2<BR></SPAN>&nbsp;&nbsp;&nbsp;<SPAN class="comment">%&nbsp;if&nbsp;lock&nbsp;obtained&nbsp;-&gt;&nbsp;ok<BR></SPAN>&nbsp;&nbsp;&nbsp;<SPAN class="comment">%&nbsp;else&nbsp;Trans&nbsp;aborted<BR></SPAN>&nbsp;&nbsp;&nbsp;{LocalStore&nbsp;waitlocks([Obj1&nbsp;Obj2])}&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;{Obj1&nbsp;inc(1)}<BR>&nbsp;&nbsp;&nbsp;{Obj1&nbsp;inc(<SPAN class="keyword">~</SPAN>1)}<BR>&nbsp;&nbsp;&nbsp;{Obj2&nbsp;inc(<SPAN class="keyword">~</SPAN>1)}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;{Obj2&nbsp;inc(2)}<BR>&nbsp;&nbsp;&nbsp;{Obj1&nbsp;inc(1)}<BR>&nbsp;&nbsp;&nbsp;Out=state({Obj1&nbsp;show($)})<BR><SPAN class="keyword">end</SPAN>&nbsp;&nbsp;&nbsp;&nbsp;<BR>OutPut&nbsp;&nbsp;<SPAN class="comment">%&nbsp;Output&nbsp;of&nbsp;Trans<BR></SPAN>Transid&nbsp;<SPAN class="comment">%&nbsp;Transaction&nbsp;Identifier<BR></SPAN>Res<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;{LocalStore&nbsp;trans(Trans&nbsp;OutPut&nbsp;?Transid)}&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="comment">%%%%&nbsp;check&nbsp;transaction<BR></SPAN>&nbsp;&nbsp;&nbsp;<SPAN class="comment">%%%%&nbsp;The&nbsp;result&nbsp;is&nbsp;commit,&nbsp;abort&nbsp;&nbsp;<BR></SPAN>&nbsp;&nbsp;&nbsp;{LocalStore&nbsp;checktrans(Transid&nbsp;Res&nbsp;_)}<BR>&nbsp;&nbsp;&nbsp;{System<SPAN class="keyword">.</SPAN>show&nbsp;Res}<BR>&nbsp;<BR></PRE></BLOCKQUOTE><P></P><H2><A name="label50">4.8  Migrate store location</A></H2><P> To enhance the reliability of GS, users can choose a specific site where the new GS will be moved. A user can migrate the GS to a specific host. This is useful for load balancing or to reduce communication latency with current GS home site. The call <CODE>{Movehere&nbsp;Module&nbsp;?LS&nbsp;Proc}</CODE> migrates the GS from its current home site to the site where <CODE>Movehere</CODE> is executed and returns the new reference to the store after migration. After the end of store migration, all dependencies with the home site are removed. </P><P class="margin"><A href="p7.oz">Source File</A></P><P> </P><BLOCKQUOTE><PRE><SPAN class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%<BR>%&nbsp;migrate&nbsp;the&nbsp;global&nbsp;store&nbsp;&nbsp;<BR>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%<BR></SPAN>{Movehere&nbsp;Module&nbsp;_&nbsp;<SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">$</SPAN>}&nbsp;<SPAN class="keyword">skip</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;}<BR></PRE></BLOCKQUOTE><P></P><P> By using the <CODE>setactionmigration</CODE>, the <CODE>LS</CODE> new store reference can be pickled and saved in a file. New clients can connect through this pickled reference. </P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node3.html#chapter.agents">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node5.html#chapter.demos">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.info.ucl.ac.be/~ila">Ilies&nbsp;Alouini </A><BR><SPAN class="version">Version 1.1.1 (20000902)</SPAN></ADDRESS></BODY></HTML>
